# Задание 3

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать,
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл.
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.

# Правки
1. После того, как прочитал статью на MDN, увидел первую ошибку - в регистрации Service Worker'а. Проблема была в том, что файл service-worker.js лежал в assets, а "Максимальная видимость scope сервис-воркера равна его location". Поэтому перенес service-worker.js в корень, чтобы gifs.html тоже попадал в scope.

2. Бросилось в глаза значение переменной CACHE_VERSION = "1.0.0 - broken". Посмотрел все функции, где она используется и выяснил, что если обновить ее значение, то это решит проблему с некорректным обновлением статики из папок vendor и assets. Делается это в функции deleteObsoleteCaches() проверкой версии кэша.

3. Логику fetch поправил следующим образом:
  1. Нашел что за проверку кэша отвечает функция needStoreForOffline()
  2. А в целом за логику обработки запроса  - вот эти строчки кода:
    if (needStoreForOffline(cacheKey)) {
        response = caches.match(cacheKey)
          .then(cacheResponse => cacheResponse || fetchAndPutToCache(cacheKey, event.request));
        } else {
            response = fetchWithFallbackToCache(event.request);
            }
        event.respondWith(response);
  3. Дальше осталось только понять, что делает функция fetchAndPutToCache и оказалось, что если needStoreForOffline() возвращает true, то достаточно просто вызвать функцию fetchAndPutToCache, чтобы взять ресурс из сети и положить его в кэш.

  #Ответы на вопросы
  1. Вопрос №1: зачем нужен этот вызов?, + Вопрос №2: зачем нужен этот вызов?
  Оба вызова нужны для ускорения активации Service Worker'а. Ответ нашел здесь: https://davidwalsh.name/service-worker-claim
  2. Вопрос №3: для всех ли случаев подойдёт такое построение ключа?
    Нет, не для всех. Например, не подойдет для запроса с GET-параметрами
  3. Вопрос №4: зачем нужна эта цепочка вызовов?
    Для затирания более старой версии кэша
  4. Вопрос №5: для чего нужно клонирование?
  "Потому, что потоки запроса и ответа могут быть прочитаны только единожды. Чтобы ответ был получен браузером и сохранен в кеше — нам нужно клонировать его. Так, оригинальный объект отправится браузеру, а клон будет закеширован. Оба они будут прочитаны единожды."
